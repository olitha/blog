== Usage in Client Calls
Where I found myself lost was in usage of Client Code. I would like to have a timeout and a retry or even a loadbalancing in a http request as well. And use the modular way Tower provides. In addition I want to have OpenTelemetry tracing in client calls with a Tower Layer.
In a later step I want to set the tracing headers in client calls.

[sidebar]
In Java you have e.g. https://resilience4j.readme.io[Resilience4j] to achieve some of that.

In Rust the most used Http clients are

reqwest:: A high level client library 
hyper:: a lower level http library for client and server

Therefore I will have a look how to achieve that for these 2 crates.

What we need to achieve is to build a "Tower" with a leaf service of the client in the end.

=== How to use Tower layers with reqwest

What we need is a leaf service that can execute reqwest requests. Oh wait that's easy icon:smile-o[]
If you take a good look at the https://docs.rs/reqwest/latest/reqwest/struct.Client.html[reqwest Client] docs. It already implements the tower service.

Great so we have that. We are able to write. 

[source, rust]
----
    let client = reqwest::Client::new();
    let mut client_service = ServiceBuilder::new()
        .service(client.clone());

    
    let req = client
        .get(...)
        .body(reqwest::Body::default())
        .build()
        .unwrap();

    let response = client_service.call(req).await.unwrap();

----

This compiles but it doesn't give us much. It only uses a *leaf* service. We have seen this before.
The difference is only that we don't call the `client.send_request` but the `service.call`.
So far there are no layers included. So let's add a Layer from the `tower-http` crate.

[source,rust]
----
 let mut client_service = ServiceBuilder::new()
    .layer(tower_http::set_header::SetRequestHeaderLayer::appending(
        HeaderName::from_static("x-test"),
        HeaderValue::from_static("true"),
    ))
    .service(client.clone());
----

You may have expected it. You get an error at `client_service.call(req)` because the type of the `req` doesn't match the type R of the `SetRequestHeader<R>`. We pass a `reqwest::Request`.
This is consistent with the type inference we have seen before. The first Layer sets the tone.

So you will have to use a `http::Request` but then the `reqwest client` doesn't accept it.
Therefore the `http::Request` must be changed to `reqwest::Request` in the chain.
The https://docs.rs/tower-reqwest/latest/tower_reqwest/index.html[tower-reqwest] service does exactly that.

You use it as the last Layer before the leaf service to adapt the http Request type to a reqwest Request type.

[source, rust]
----
async fn adapt_to_reqwest() {
    let mock_server = crate::start_echo_server().await;

    let client = reqwest::Client::new();
    let mut client_service = ServiceBuilder::new()
        .layer(tower_http::set_header::SetRequestHeaderLayer::appending(
            HeaderName::from_static("x-test"),
            HeaderValue::from_static("true"),
        ))
        .layer(HttpClientLayer)
        .service(client.clone());

    let req = http::request::Builder::new()
        .method(http::Method::GET)
        .uri(format!("{}/headers", mock_server.uri()))
        .body(reqwest::Body::default())
        .unwrap();

    let response = client_service.call(req).await.unwrap();

}
----
WARNING: link to source adapt_to_reqwest

